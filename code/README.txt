This is a simple framework for evalutating local realistic models of
two-photon correlation.  I developed it for my own entertainment and
may document it more thoroughly at some future date.

To run a simulation in the de Raedt model, use a command line like:

python epyr_source_process.py 1000000 de_raedt_model/de_raedt_epyr_test.py CORRELATED UNIFORM

The arguements are: the number of shots, the implementation file to load, a CORRELATED
flag to say that correlated photon pairs ought to be generated and a UNIFORM flag
indicating that rather than just the EPR angles the dataset ought to contain a
unform distribution of polarizer angle differences.  The alternatives to CORRELATED and
UNFORM are UNCORRELATED and EPR.

The framework does all the book-keeping and plumbing.  Ultimately three processes are
started:  the main source process and two detector processes.  Each one loads and
exec's the file named on the command line, but do different things with it.

The source process creates an object of type TestSource, and this type--derived from
EPyRSource--must define two methods: GenerateCorrelatedPair(self, nCount, fTime) and
GenerateUncorrelatedPair(self, nCount, fTime).  These must return a tuple of photons
with two members.  The photons can be anything:  in the de Raedt example I've used
colon-delimited numerical values.

The nCount and fTime arguments are a sequential count of the pair and a strictly increasing but otherwise random time that the pair was generate at.  The time step
is sampled from the interval [0, 1].

The detector processes create objects of type TestDetector--derived from
EPyRDetector--whose constructor takes a string that identifies the detector.  It 
will be either "D1" or "D2".  This class must define the method:

	ProcessPhoton(self, fDetectorAngle, strPhoton)

The fDetectorAngle argument is the setting for this polarizer in radians.  The
strPhoton argument is nothing but one of the photon strings generated by the
TestSource.

This method must return a tuple containing: (nCount, fTimeTag, fDetectorAngle, strResult)

The nCount value should be the same as the one passed in to the Generate*Pair method
of the source, and so this value needs to be encoded in the photon string.  The
fTimeTag value could be just the time passed in, or it could be something more
elaborate, as used in the de Raedt model.  Ideally, however, it should reflect
the actual time the photon is detected after any propogation delays etc.  The 
generation time should in most cases also be encoded in the photon string for use 
by this method.  The returned angle should also be in radians:  just pass through the
input value in all but the most pathological cases.

The strResult value should be one of "L" or "R", indicating which arm of the spectrometer
the photon is detected on.  Of course, other values, such as "N" for undetected
photons, could also be added.

During a run the simulation will generate two files:  detector_d1_output.txt and
detector_d2_output.txt which contain just the tuple values generated by the 
appropriate detector.  Note that for "UNIFORM" runs detctor 1 will have fixed
angle at 180 degrees, and that the angle in the file has been converted into
degrees to be more human-readable and have nice string values for the EPR
settings.

The photon strings are completely general:  they could if you wanted contain actual
Python code that the detector ProcessPhoton method exec's.

Any local realistic theory can be simulated within this framework.  If it can't be,
then it can't predict the results of experiment, which are a series of events at
the individual detectors.

Depending on the kind of data (EPR or UNIFORM) the analysis will have to do different
things, but it's important that both types of data be examined, particularly in ways
that reveal the unphysical aspects of the model.
